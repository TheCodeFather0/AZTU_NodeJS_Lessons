import { Observable } from 'rxjs';
import Base from './baseUI.js';
import type { InquirerReadline } from '@inquirer/type';
import type { Answers, Question, QuestionAnswerMap, QuestionArray, QuestionObservable, StreamOptions } from '../types.js';
export interface PromptBase {
    /**
     * Runs the prompt.
     *
     * @returns
     * The result of the prompt.
     */
    run(): Promise<any>;
    close(): void;
}
/**
 * Provides the functionality to initialize new prompts.
 */
export interface LegacyPromptConstructor {
    /**
     * Initializes a new instance of a prompt.
     *
     * @param question
     * The question to prompt.
     *
     * @param readLine
     * An object for reading from the command-line.
     *
     * @param answers
     * The answers provided by the user.
     */
    new (question: any, readLine: InquirerReadline, answers: Record<string, any>): PromptBase;
}
export type PromptFn<Value = any, Config = any> = (config: Config, context?: StreamOptions) => Promise<Value>;
/**
 * Provides a set of prompt-constructors.
 */
export type PromptCollection = Record<string, PromptFn | LegacyPromptConstructor>;
/**
 * Base interface class other can inherits from
 */
export default class PromptsRunner<T extends Answers = Answers> extends Base {
    prompts: PromptCollection;
    answers: Partial<T>;
    process: Observable<any>;
    opt?: StreamOptions;
    rl?: InquirerReadline;
    constructor(prompts: PromptCollection, opt?: StreamOptions);
    run(questions: Question<T> | QuestionAnswerMap<T> | QuestionObservable<T> | QuestionArray<T>, answers?: Partial<T>): Promise<T> & {
        ui: PromptsRunner;
    };
    /**
     * Once all prompt are over
     */
    onCompletion(): Partial<T>;
    onError(error: Error): Promise<never>;
    processQuestion(question: Question<T>): Observable<{
        name: keyof T;
        answer: any;
    }>;
    fetchAnswer(question: Question<T>): Observable<{
        name: keyof T;
        answer: any;
    }>;
    setDefaultType(question: Question<T>): Observable<Question<T>>;
    filterIfRunnable(question: Question<T>): Observable<Question<T>>;
}
